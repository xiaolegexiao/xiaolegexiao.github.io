<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>肖了个肖的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-02T02:14:22.777Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiaolegexiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>静态方法中使用自动注入的对象</title>
    <link href="http://yoursite.com/2019/07/02/postConstruct/"/>
    <id>http://yoursite.com/2019/07/02/postConstruct/</id>
    <published>2019-07-02T01:34:36.000Z</published>
    <updated>2019-07-02T02:14:22.777Z</updated>
    
    <content type="html"><![CDATA[<p>前几天碰到一个需求，需要在静态方法中调用引入的对象，大家都知道在静态方法中是不能直接使用自动注入的对象，因为静态方法是在类被加载时装载到内存，对象属性是在对象实例化时装载，那么如何在静态方法中调用非静态方法？  </p><p>首先大家要知道一个类的加载顺序一般是：<br>静态变量、静态初始化块）–&gt;（变量、初始化块）–&gt; 构造器；<br>如果有父类，则顺序是：父类static方法 –&gt; 子类static方法 –&gt; 父类构造方法- -&gt; 子类构造方法。</p><p>我们此时注入的对象还没有被自动注入，值为null；<br>JavaEE5引入了<strong>@postConstuct</strong>和<strong>@PreDestroy</strong>注解，该注解是用来修饰一个非静态的void()方法，实现bean初始化之前和销毁之前的一些操作。   </p><p><strong>使用说明：</strong><br><strong>@postConstruct</strong> 注释用于在依赖关系注入完成之后需要执行的方法上，以执行任何初始化。此方法必须在将类放入服务之前调用。支持依赖关系注入的所有类都必须支持此注释。即使类没有请求注入任何资源，用 @postConstruct 注释的方法也必须被调用。只有一个方法可以用此注释进行注释。  </p><p><strong>写法：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@PostConstruct</span> <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong><br>该方法不得有任何参数；<br>该方法的返回类型必须为 void；<br>该方法不得抛出已检查异常；<br>应用 PostConstruct 的方法可以是 public、protected、package private 或 private；<br>该方法不能是 static；该方法可以是 final；<br>该方法只会被执行一次。</p><p><strong>实际使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Some some;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> test test;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        test = <span class="keyword">this</span>;</span><br><span class="line">        test.some = <span class="keyword">this</span>.some;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">testSomeThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(some.<span class="keyword">do</span>());</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>加载顺序：构造函数—- @Autowire—–@PostConstruct<br>该类必须由Spring容器进行管理，必须加上@autowire注解，此时就可以在静态方法中调用自动注入的对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天碰到一个需求，需要在静态方法中调用引入的对象，大家都知道在静态方法中是不能直接使用自动注入的对象，因为静态方法是在类被加载时装载到内存，对象属性是在对象实例化时装载，那么如何在静态方法中调用非静态方法？  &lt;/p&gt;
&lt;p&gt;首先大家要知道一个类的加载顺序一般是：&lt;br&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AWS搭建Shadowsocks</title>
    <link href="http://yoursite.com/2019/07/01/aws-ss/"/>
    <id>http://yoursite.com/2019/07/01/aws-ss/</id>
    <published>2019-07-01T05:55:02.000Z</published>
    <updated>2019-07-01T07:28:03.991Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Tips：必须要信用卡(可消费外币)</strong></p><p>1.<strong>注册AWS</strong><br>注册时需要填写信用卡会预授权付款1刀，并且注册时会通过电话方式发送验证码(中文)，要注意的是AWS免费每月750小时,如果你创建多个实例，那你每月的时长是多个实例的运行时间，千万不要超了。  </p><p>2.<strong>创建AWS实例</strong><br>1.<em>创建EC2实例</em><br><img src="//yoursite.com/2019/07/01/aws-ss/1.png" alt="选择EC2实例"><br><img src="//yoursite.com/2019/07/01/aws-ss/2.png" alt="启动EC2实例"><br><img src="//yoursite.com/2019/07/01/aws-ss/3.png" alt="选择免费的AMI"><br><img src="//yoursite.com/2019/07/01/aws-ss/4.png" alt="审核和启动"><br><img src="//yoursite.com/2019/07/01/aws-ss/5.png" alt="选择创建新的密钥对，然后下载密钥对，将密钥对存储起来"><br><img src="//yoursite.com/2019/07/01/aws-ss/6.png" alt="EC2实例已经创建完成">  </p><p>3.<strong>连接EC2实例</strong><br>这里使用Xshell进行连接，也可以使用<a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/AccessingInstances.html" target="_blank" rel="noopener">官方方法</a>。<img src="//yoursite.com/2019/07/01/aws-ss/7.png" alt="复制你EC2 IPv4公有IP，点击用户身份验证选择publicKey，导入之前保存的密钥对pem文件，用户名必须为ubuntu">  </p><p>4.<strong>安装SS</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.获取系统root权限</span><br><span class="line">   sudo -s</span><br><span class="line"><span class="number">2</span>.更新apt-get</span><br><span class="line">  apt-get update</span><br><span class="line"><span class="number">3</span>.安装python包管理工具</span><br><span class="line">   apt-get install python-setuptools</span><br><span class="line">   apt-get install python-pip</span><br><span class="line"><span class="number">4</span>.安装shadowsocks</span><br><span class="line">   pip install shadowsocks</span><br><span class="line"><span class="number">5</span>.创建ss配置文件</span><br><span class="line">   mkdir /etc/shadowsocks</span><br><span class="line">   vim /etc/shadowsocks/ss.json</span><br><span class="line">   在打开的文件中按”i”键进入insert模式，然后输入</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="string">"server_port"</span>:<span class="number">443</span>,</span><br><span class="line">    <span class="string">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="string">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="string">"password"</span>:<span class="string">"你要设置的密码"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="string">"fast_open"</span>:<span class="keyword">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  按”ESC”退出Insert模式，再输入”:wq”保存退出配置文件。配置文件中的端口号和密码可以自行设置。</span><br></pre></td></tr></table></figure><p>5.<strong>启动SS</strong><br>    ssserver -c /etc/shadowsocks.json -d start<br>    如果错误：</p><pre><code class="Java"> File “/usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py”, line <span class="number">52</span>, in load_openssllibcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)File “/usr/lib/python2.7/ctypes/init.py”, line <span class="number">375</span>, in getattrfunc = self.getitem(name)File “/usr/lib/python2.7/ctypes/init.py”, line <span class="number">380</span>, in getitemfunc = self._FuncPtr((name_or_ordinal, self))AttributeError: /usr/lib/x86_64-Linux-gnu/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup    这是由于在 openssl1.1.0版本中，EVP_CIPHER_CTX_cleanup函数被替换为EVP_CIPHER_CTX_reset。    修改方法：<span class="number">1</span>.用vim打开文件：vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py (该路径请根据自己的系统情况自行修改，如果不知道该文件在哪里的话，可以使用find命令查找文件位置)<span class="number">2</span>.跳转到<span class="number">52</span>行（shadowsocks2.8.2版本，其他版本搜索一下cleanup）<span class="number">3</span>.进入编辑模式<span class="number">4</span>.将第<span class="number">52</span>行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,) 改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)<span class="number">5</span>.再次搜索cleanup（全文件共<span class="number">2</span>处，此处位于<span class="number">111</span>行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx) 改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)<span class="number">6</span>.保存并退出<span class="number">7</span>.启动shadowsocks服务：service shadowsocks start 或 sslocal -c ss配置文件目录<span class="number">8</span>.问题解决</code></pre><p>6.<strong>配置EC2实例入站规则</strong><br><img src="//yoursite.com/2019/07/01/aws-ss/8.png" alt="入站规则"><br><img src="//yoursite.com/2019/07/01/aws-ss/9.png" alt="添加入站规则"></p><p>7.<strong>SS客户端</strong><br><img src="//yoursite.com/2019/07/01/aws-ss/10.png" alt="添加入站规则">  </p><p><strong>ps：右击任务栏右下角的小飞机图标，可以设置相应的属性项，包括开启自启，显示日志，PAC设置，系统代理模式等等。其中系统代理模式中的全局模式是指所有的请求都走代理（国内以及国外的），而PAC模式则是自动识别，国内的直连，国外的（例如Google，YouTube）走代理。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Tips：必须要信用卡(可消费外币)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;注册AWS&lt;/strong&gt;&lt;br&gt;注册时需要填写信用卡会预授权付款1刀，并且注册时会通过电话方式发送验证码(中文)，要注意的是AWS免费每月750小时,如果你创建多个
      
    
    </summary>
    
      <category term="AWS" scheme="http://yoursite.com/categories/AWS/"/>
    
    
      <category term="AWS SS" scheme="http://yoursite.com/tags/AWS-SS/"/>
    
  </entry>
  
</feed>
